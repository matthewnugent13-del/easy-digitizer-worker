import os
from io import BytesIO
import io, csv
import math
import colorsys
from typing import List, Tuple, Dict

import streamlit as st
from PIL import Image, ImageDraw

# ---- DST reader (correct API) ----
from pyembroidery import read as read_emb, EmbPattern, STITCH, JUMP, TRIM, COLOR_CHANGE, END

def _read_pattern(path: str) -> "EmbPattern":
    if not isinstance(path, (str, bytes, os.PathLike)):
        raise TypeError(f"Expected a file path string, got {type(path).__name__}")
    return read_emb(path)  # returns EmbPattern

from thread_colors import THREAD_BRANDS, map_palette_to_brand  # color recommendations

from preprocess import fit_to_hoop
from quantize import quantize_image
from vectorize import extract_color_regions, draw_contour_overlay
from ordering import compute_color_areas, clip_by_stack
from stitcher import (
    outline_then_fill_layers_universal,
    normalize_layers,
    plan_commands_from_layers,
    FILL_INSET_MM,
    MAX_RUN_TRAVEL_MM,
    MAX_JUMP_MM,
    RUN_STEP_MM,
)
from writer import save_dst

st.set_page_config(page_title="Embroidery MVP", page_icon="ðŸ§µ", layout="wide")
os.makedirs("output", exist_ok=True)

if "dst_bytes" not in st.session_state:
    st.session_state.dst_bytes = None
if "dst_name" not in st.session_state:
    st.session_state.dst_name = None
if "dst_path" not in st.session_state:
    st.session_state.dst_path = None
if "color_run_rgb" not in st.session_state:
    st.session_state.color_run_rgb = None  # list of RGB tuples for each color step


def _load_image(file) -> Image.Image:
    data = file.read()
    img = Image.open(BytesIO(data))
    return img.convert("RGBA") if img.mode in ("RGBA", "LA") else img.convert("RGB")


def _trim_count(cmd_layers) -> int:
    return sum(
        1
        for cmds in cmd_layers.values()
        for (c, _, _) in cmds
        if str(c).lower().startswith("t")
    )


def _suppress_trims(cmd_layers):
    """Drop TRIM commands so machine won't stop between regions; keep JUMPs only."""
    new = {}
    for k, seq in cmd_layers.items():
        out = []
        last_xy = None
        for (cmd, x, y) in seq:
            c = str(cmd).lower().strip()
            if c.startswith("t"):
                # drop trims entirely
                continue
            # drop zero-length jumps (no-op)
            if c.startswith("j") and last_xy is not None:
                if abs(last_xy[0] - x) < 1e-9 and abs(last_xy[1] - y) < 1e-9:
                    continue
            out.append((cmd, x, y))
            last_xy = (x, y)
        new[k] = out
    return new


# ---------- VIEWER HELPERS ----------
def _auto_colors(n: int) -> List[Tuple[int, int, int]]:
    # simple evenly-spaced hue wheel
    out = []
    for i in range(max(1, n)):
        h = i / max(1, n)
        r, g, b = _hsv_to_rgb(h, 0.75, 0.95)
        out.append((int(r * 255), int(g * 255), int(b * 255)))
    return out

def _hsv_to_rgb(h, s, v):
    i = int(h * 6.0)
    f = h * 6.0 - i
    p = v * (1.0 - s)
    q = v * (1.0 - f * s)
    t = v * (1.0 - (1.0 - f) * s)
    i = i % 6
    if i == 0: r, g, b = v, t, p
    elif i == 1: r, g, b = q, v, p
    elif i == 2: r, g, b = p, v, t
    elif i == 3: r, g, b = p, q, v
    elif i == 4: r, g, b = t, p, v
    else: r, g, b = v, p, q
    return r, g, b

def _ensure_dst_on_disk() -> str:
    """We save the generated bytes to a predictable path if needed, then return path."""
    if st.session_state.dst_path and os.path.exists(st.session_state.dst_path):
        return st.session_state.dst_path
    # write from bytes if present
    if st.session_state.dst_bytes:
        tmp = os.path.join("output", st.session_state.dst_name or "design.dst")
        with open(tmp, "wb") as f:
            f.write(st.session_state.dst_bytes)
        st.session_state.dst_path = tmp
        return tmp
    raise FileNotFoundError("No DST available to view.")

def _parse_pattern_by_color(pat: "EmbPattern"):
    """
    Split stitches into color steps, jumps, and trim points.
    Returns: dict with keys:
      - 'steps': List[{'polylines': List[List[Tuple[x,y]]], 'stitch_count': int}]
      - 'jumps': List[List[Tuple[x,y]]]  (across all colors)
      - 'trims': List[Tuple[x,y]]
      - 'bounds': (minx, miny, maxx, maxy)
    """
    stitches = list(getattr(pat, "stitches", []))
    if not stitches:
        try:
            stitches = list(pat.get_stitches())  # type: ignore
        except Exception:
            stitches = []

    steps: List[Dict] = []
    jumps: List[List[Tuple[float, float]]] = []
    trims: List[Tuple[float, float]] = []

    cur_step = {"polylines": [], "stitch_count": 0}
    cur_poly: List[Tuple[float, float]] = []
    cur_jump: List[Tuple[float, float]] = []

    minx = miny = 1e18
    maxx = maxy = -1e18

    def _flush_poly():
        nonlocal cur_poly, cur_step
        if len(cur_poly) >= 2:
            cur_step["polylines"].append(cur_poly)
        cur_poly = []

    def _flush_jump():
        nonlocal cur_jump, jumps
        if len(cur_jump) >= 2:
            jumps.append(cur_jump)
        cur_jump = []

    # Correct tuple order from pyembroidery: (x, y, cmd)
    for (x, y, cmd) in stitches:
        x = float(x); y = float(y)
        # track bounds
        minx = min(minx, x); maxx = max(maxx, x)
        miny = min(miny, y); maxy = max(maxy, y)

        if cmd == STITCH:
            cur_poly.append((x, y))
            cur_step["stitch_count"] += 1

        elif cmd == JUMP:
            _flush_poly()
            cur_jump.append((x, y))

        elif cmd == TRIM:
            _flush_poly()
            _flush_jump()
            trims.append((x, y))

        elif cmd == COLOR_CHANGE:
            _flush_poly()
            _flush_jump()
            if cur_step["polylines"] or cur_step["stitch_count"] > 0:
                steps.append(cur_step)
            else:
                steps.append({"polylines": [], "stitch_count": 0})
            cur_step = {"polylines": [], "stitch_count": 0}

        elif cmd == END:
            break

        else:
            _flush_poly()
            _flush_jump()

    # flush leftovers
    _flush_poly(); _flush_jump()
    if cur_step["polylines"] or cur_step["stitch_count"] > 0:
        steps.append(cur_step)

    if minx > maxx or miny > maxy:
        minx = miny = 0.0; maxx = maxy = 1.0

    return {
        "steps": steps,
        "jumps": jumps,
        "trims": trims,
        "bounds": (minx, miny, maxx, maxy),
    }

def _vividize_palette(src: List[Tuple[int,int,int]] | None, n_steps: int) -> List[Tuple[int,int,int]]:
    """
    Return a high-contrast palette for display:
    - Use real thread colors if theyâ€™re colorful enough.
    - If a color is gray/low-saturation, substitute an auto vivid color.
    """
    auto = _auto_colors(n_steps)
    out: List[Tuple[int,int,int]] = []
    for i in range(n_steps):
        if src and i < len(src):
            r, g, b = src[i]
            h, s, v = colorsys.rgb_to_hsv(r/255.0, g/255.0, b/255.0)
            if s < 0.25:  # too gray â†’ use a distinct vivid color
                out.append(auto[i])
            else:
                s = max(s, 0.85); v = max(v, 0.90)
                rr, gg, bb = colorsys.hsv_to_rgb(h, s, v)
                out.append((int(rr*255), int(gg*255), int(bb*255)))
        else:
            out.append(auto[i])
    return out

def _render_preview(
    pat: "EmbPattern",
    step_colors: List[Tuple[int,int,int]] | None,
    width_px: int = 900,
    stroke_px: int = 2,
    show_jumps: bool = True,
    show_trims: bool = True,
    flip_vertical: bool = False,   # no flip so it's not upside-down
    show_grid_mm: bool = False,
    unit_scale: float = 10.0       # our writer uses 10 units/mm (0.1 mm units)
):
    data = _parse_pattern_by_color(pat)
    steps = data["steps"]; jumps = data["jumps"]; trims = data["trims"]
    (minx, miny, maxx, maxy) = data["bounds"]

    # Build vivid display palette (distinct even if real threads are gray)
    n_steps = len(steps)
    disp_colors = _vividize_palette(step_colors, n_steps)

    w_units = max(1e-6, maxx - minx)
    h_units = max(1e-6, maxy - miny)
    aspect = h_units / w_units
    pad = 16
    W = int(width_px)
    H = int(W * aspect) if aspect > 0 else W
    H = max(H, 200)
    canvas = Image.new("RGB", (W + pad*2, H + pad*2), (255, 255, 255))
    draw = ImageDraw.Draw(canvas)

    # coordinate transform (preserve aspect)
    scale = W / w_units
    def tx(x: float) -> int:
        return int(pad + (x - minx) * scale)
    def ty(y: float) -> int:
        if flip_vertical:
            return int(pad + (maxy - y) * scale)
        return int(pad + (y - miny) * scale)

    # optional grid every 10 mm
    if show_grid_mm:
        grid_mm = 10.0
        w_mm = w_units / unit_scale
        h_mm = h_units / unit_scale
        color_grid = (230, 230, 230)
        n_v = int(math.floor(w_mm / grid_mm))
        for i in range(1, n_v + 1):
            x_u = minx + (i * grid_mm * unit_scale)
            x = tx(x_u)
            draw.line([(x, pad), (x, pad + H)], fill=color_grid, width=1)
        n_h = int(math.floor(h_mm / grid_mm))
        for j in range(1, n_h + 1):
            y_u = miny + (j * grid_mm * unit_scale)
            y = ty(y_u)
            draw.line([(pad, y), (pad + W, y)], fill=color_grid, width=1)

    # draw per-color polylines
    for i, step in enumerate(steps):
        col = disp_colors[i % len(disp_colors)]
        for pl in step["polylines"]:
            if len(pl) >= 2:
                pts = [(tx(x), ty(y)) for (x, y) in pl]
                draw.line(pts, fill=col, width=stroke_px, joint="curve")

    # draw jumps (across colors)
    if show_jumps:
        for jpl in jumps:
            if len(jpl) >= 2:
                pts = [(tx(x), ty(y)) for (x, y) in jpl]
                draw.line(pts, fill=(180, 180, 180), width=max(1, stroke_px-1))

    # mark trims
    if show_trims and trims:
        for (x, y) in trims:
            cx, cy = tx(x), ty(y)
            r = max(3, stroke_px + 1)
            draw.ellipse((cx - r, cy - r, cx + r, cy + r), outline=(220, 0, 0), width=2)

    color_stats = [{"Step": i+1, "Stitches": int(steps[i]["stitch_count"])} for i in range(len(steps))]
    return canvas, {
        "steps": len(steps),
        "trims": len(trims),
        "color_stats": color_stats,
    }


# ---------- UI ----------
st.title("Embroidery Auto-Digitizer")

# 1) Upload
st.subheader("1) Upload")
only_alpha_bg = st.checkbox("Ignore transparent pixels only (keep whites)", value=True)
file = st.file_uploader("PNG or JPG", type=["png", "jpg", "jpeg"])
if not file:
    st.info("Upload an image to start.")
    if st.session_state.dst_bytes:
        st.download_button(
            "Download last DST",
            st.session_state.dst_bytes,
            file_name=st.session_state.dst_name or "design.dst",
            mime="application/octet-stream",
        )
    st.stop()

src = _load_image(file)

# 2) Fit to hoop (preserves alpha)
px_per_mm = 10.0
fitted = fit_to_hoop(src, hoop_mm=(130.0, 180.0), px_per_mm=px_per_mm)

c1, c2 = st.columns(2)
c1.image(src, caption="Original", use_container_width=True)
c2.image(fitted, caption="Fitted to 130Ã—180 mm", use_container_width=True)

# 3) Preset
st.subheader("2) Preset")
preset = st.selectbox("Style", ["Universal Auto (default)", "Crisp Logos"], index=0)

if preset == "Universal Auto (default)":
    params = dict(
        satin_max_width_mm=4.5,
        split_satin_max_width_mm=10.0,
        tatami_spacing_mm=0.50,
        narrow_fill_spacing_mm=0.60,
        satin_spacing_mm=0.40,
        base_angle_deg=0.0,
        angle_mode="per_color_random",
        angle_jitter_deg=0.0,
        pull_comp_mm=0.30,
        tatami_bleed_mm=0.08,
        serpentine=True,
        outline_step_px=2.5,
    )
else:
    params = dict(
        satin_max_width_mm=5.0,
        split_satin_max_width_mm=12.0,
        tatami_spacing_mm=0.48,
        narrow_fill_spacing_mm=0.55,
        satin_spacing_mm=0.38,
        base_angle_deg=0.0,
        angle_mode="per_color_random",
        angle_jitter_deg=0.0,
        pull_comp_mm=0.40,
        tatami_bleed_mm=0.10,
        serpentine=True,
        outline_step_px=2.5,
    )

# 4) Colors (quantize)
st.subheader("3) Colors")
max_colors = st.slider("Max colors", 2, 8, 6)
indexed_img, palette_rgb, qprev = quantize_image(
    fitted,
    n_colors=max_colors,
    remove_bg=True,
    ignore_alpha_only=only_alpha_bg,  # keep whites; only drop transparent
    alpha_threshold=8,
)
st.image(qprev, caption=f"Quantized preview (up to {max_colors} colors)", use_container_width=True)

# 5) Vectorize & stack
st.subheader("4) Vectorize")
min_region_px = st.slider("Min region size (px)", 50, 1200, 180, step=10)
regions = extract_color_regions(indexed_img, min_region_px=min_region_px, smooth_px=2.0)

areas = compute_color_areas(regions)
stack_order = sorted(areas.keys(), key=lambda k: areas[k], reverse=True)
if st.checkbox("Clip overlaps by stack", value=True):
    regions = clip_by_stack(regions, stack_order, margin_mm=0.05)

overlay = draw_contour_overlay(fitted.convert("RGB"), regions, palette_rgb)
st.image(overlay, caption="Detected regions (white preserved if present)", use_container_width=True)

# 5) Options (generation-time options are okay to keep)
st.subheader("5) Options")
prefer_jumps = st.checkbox(
    "Prefer jumps (no trims between regions)",
    value=False,
    help="Replaces trim commands with jumps so a single-needle machine won't stop except at color changes.",
)
brand_name = st.selectbox(
    "Thread brand for recommendations (for the Color Run Sheet)",
    list(THREAD_BRANDS.keys()),
    index=0,
)

# 6) Generate
st.subheader("6) Generate DST")
if st.button("Generate"):
    try:
        if not regions:
            st.error("No stitchable regions. Try increasing max colors or lowering min region size.")
            st.stop()

        layers_px = outline_then_fill_layers_universal(
            regions,
            px_per_mm=px_per_mm,
            outline_step_px=float(params["outline_step_px"]),
            base_angle_deg=float(params["base_angle_deg"]),
            tatami_spacing_mm=float(params["tatami_spacing_mm"]),
            tatami_inset_mm=float(FILL_INSET_MM),
            tatami_bleed_mm=float(params["tatami_bleed_mm"]),
            narrow_fill_spacing_mm=float(params["narrow_fill_spacing_mm"]),
            satin_spacing_mm=float(params["satin_spacing_mm"]),
            angle_mode=str(params["angle_mode"]),
            angle_jitter_deg=float(params["angle_jitter_deg"]),
            serpentine=bool(params["serpentine"]),
            satin_max_width_mm=float(params["satin_max_width_mm"]),
            split_satin_max_width_mm=float(params["split_satin_max_width_mm"]),
            pull_comp_mm=float(params["pull_comp_mm"]),
        )

        layers_px = normalize_layers(layers_px, translate_origin="min")

        cmd_layers = plan_commands_from_layers(
            layers_px,
            px_per_mm=px_per_mm,
            max_run_mm=float(MAX_RUN_TRAVEL_MM),
            max_jump_mm=float(MAX_JUMP_MM),
            run_step_mm=float(RUN_STEP_MM),
            regions=regions,
            run_inside_regions_only=True,
            run_inset_mm=0.30,
        )

        # --- Trim counting & optional suppression ---
        trim_count_raw = _trim_count(cmd_layers)
        if prefer_jumps:
            cmd_layers = _suppress_trims(cmd_layers)
        trim_count_final = _trim_count(cmd_layers)

        out_name = "design.dst"
        out_path = os.path.join("output", out_name)
        save_dst(
            cmd_layers,
            out_path,
            palette_rgb=palette_rgb,
            color_order=stack_order,
            px_per_mm=px_per_mm,
        )

        # store bytes and path for later viewing
        with open(out_path, "rb") as f:
            st.session_state.dst_bytes = f.read()
        st.session_state.dst_name = out_name
        st.session_state.dst_path = out_path

        # store the RGB sequence for the viewer (one color per color-change block)
        st.session_state.color_run_rgb = [
            tuple(int(c) for c in palette_rgb[idx]) for idx in stack_order
        ]

        st.success(f"Saved: {out_path}")
        if prefer_jumps:
            st.info(f"Trim events in this DST: {trim_count_final} (suppressed from {trim_count_raw})")
        else:
            st.info(f"Trim events in this DST: {trim_count_final}")

        # --- Color Run Sheet (stitch order + recommendations) ---
        try:
            recs = map_palette_to_brand(palette_rgb, brand=brand_name)
            total_area = sum(areas.values()) or 1.0
            rows = []
            for step, color_idx in enumerate(stack_order, start=1):
                rgb = tuple(int(v) for v in (palette_rgb[color_idx] if color_idx < len(palette_rgb) else (0, 0, 0)))
                hexv = recs[color_idx]["hex"] if color_idx < len(recs) else "#000000"
                code = recs[color_idx]["code"] if color_idx < len(recs) else "N/A"
                name = recs[color_idx]["name"] if color_idx < len(recs) else "N/A"
                pct  = (areas.get(color_idx, 0) / total_area) * 100.0
                rows.append({
                    "Step": step,
                    "Palette Index": color_idx,
                    "RGB": f"{rgb}",
                    "HEX": hexv,
                    "Recommended": f"{code} â€” {name}",
                    "Est. Area %": f"{pct:.1f}%",
                })
            st.markdown("### Color Run Sheet")
            st.dataframe(rows, use_container_width=True)

            buf = io.StringIO()
            writer = csv.DictWriter(buf, fieldnames=list(rows[0].keys()))
            writer.writeheader()
            writer.writerows(rows)
            st.download_button(
                "Download Color Run Sheet (CSV)",
                buf.getvalue().encode("utf-8"),
                file_name="color_run_sheet.csv",
                mime="text/csv",
            )
        except Exception:
            st.warning("Color Run Sheet not available for this design.")

    except Exception as e:
        st.error("Generation failed.")
        st.exception(e)

# 7) DST Viewer (always renders after a DST exists; no viewer toggles)
st.subheader("7) DST Viewer")
if st.session_state.dst_bytes:
    try:
        path = _ensure_dst_on_disk()
        pat = _read_pattern(path)
        img, stats = _render_preview(
            pat,
            step_colors=st.session_state.color_run_rgb,  # base hues on the real run
            width_px=900,        # fixed width
            stroke_px=2,         # fixed stroke
            show_jumps=True,
            show_trims=True,
            flip_vertical=False, # correct orientation
            show_grid_mm=False,
            unit_scale=10.0,
        )
        st.image(img, caption=f"Rendered from {os.path.basename(path)}", use_container_width=False)
        st.caption(f"Color steps: {stats['steps']} â€¢ Trims: {stats['trims']}")
    except Exception as e:
        st.warning("Could not render DST preview.")
        st.exception(e)
else:
    st.info("Generate a DST to see the preview.")

# 8) Download
st.subheader("Download")
if st.session_state.dst_bytes:
    st.download_button(
        "Download DST",
        data=st.session_state.dst_bytes,
        file_name=st.session_state.dst_name or "design.dst",
        mime="application/octet-stream",
    )
else:
    st.info("No DST generated yet.")
